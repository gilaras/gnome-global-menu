--- gtk/gtkmenubar.orig	2007-12-30 21:34:19.000000000 -0500
+++ gtk/gtkmenubar.c	2007-12-30 22:03:52.000000000 -0500
@@ -39,10 +39,14 @@
 #include "gtkprivate.h"
 #include "gtkalias.h"
 
-
+#include "x11/gdkx.h"
+#define INCLUDE_SOURCE
+#include "gtkmenuembed-x11.h"
+#undef INCLUDE_SOURCE
 #define BORDER_SPACING  0
 #define DEFAULT_IPADDING 1
 
+#define LOG_FUNC_NAME g_message("%s invoked", __func__)
 /* Properties */
 enum {
   PROP_0,
@@ -55,6 +59,12 @@
 {
   GtkPackDirection pack_direction;
   GtkPackDirection child_pack_direction;
+
+  GlobalMenuSocket * socket;
+  gboolean globalized;
+  GdkWindow * float_window;
+  GdkWindow * container_window;
+  GdkWindow * master_window;
 };
 
 #define GTK_MENU_BAR_GET_PRIVATE(o)  \
@@ -83,6 +93,13 @@
 static void gtk_menu_bar_move_current      (GtkMenuShell     *menu_shell,
                                             GtkMenuDirectionType direction);
 
+static void gtk_menu_bar_finalize            (GObject         *object);
+static void gtk_menu_bar_realize            (GtkWidget         *widget);
+static void gtk_menu_bar_unrealize            (GtkWidget         *widget);
+static void gtk_menu_bar_map				(GtkWidget * widget);
+static void gtk_menu_bar_unmap				(GtkWidget * widget);
+static void gtk_menu_bar_real_insert (GtkMenuShell * menu_shell, GtkWidget * child, gint position);
+static void gtk_menu_bar_notify_size_allocate_cb (GlobalMenuSocket * socket, GlobalMenuNotify * notify, GtkMenuBar * menubar);
 static GtkShadowType get_shadow_type   (GtkMenuBar      *menubar);
 
 G_DEFINE_TYPE (GtkMenuBar, gtk_menu_bar, GTK_TYPE_MENU_SHELL)
@@ -112,6 +129,14 @@
   menu_shell_class->get_popup_delay = gtk_menu_bar_get_popup_delay;
   menu_shell_class->move_current = gtk_menu_bar_move_current;
 
+/*****global menu patched code ********/
+  gobject_class->finalize = gtk_menu_bar_finalize;
+  widget_class->realize = gtk_menu_bar_realize;  
+  widget_class->unrealize = gtk_menu_bar_unrealize;  
+  widget_class->map = gtk_menu_bar_map;
+  widget_class->unmap = gtk_menu_bar_unmap;
+  menu_shell_class->insert = gtk_menu_bar_real_insert;
+
   binding_set = gtk_binding_set_by_class (class);
   gtk_binding_entry_add_signal (binding_set,
 				GDK_Left, 0,
@@ -220,6 +245,11 @@
 static void
 gtk_menu_bar_init (GtkMenuBar *object)
 {
+	GtkMenuBarPrivate * priv;
+	priv = GTK_MENU_BAR_GET_PRIVATE(object);
+	
+	priv->socket = global_menu_socket_new(MENU_CLIENT_NAME, object);
+	global_menu_socket_set_callback(priv->socket, GM_NOTIFY_SIZE_ALLOCATE, gtk_menu_bar_notify_size_allocate_cb);
 }
 
 GtkWidget*
@@ -646,6 +676,8 @@
 {
   GList *menubars = get_menu_bars (window);
 
+LOG_FUNC_NAME;
+
   if (!menubars)
     {
       g_signal_connect (window,
@@ -663,6 +695,8 @@
 {
   GList *menubars = get_menu_bars (window);
 
+LOG_FUNC_NAME;
+
   menubars = g_list_remove (menubars, menubar);
 
   if (!menubars)
@@ -938,5 +972,231 @@
     }
 }
 
+/************* Global menu patched methods ***************/
+static void gtk_menu_bar_finalize            (GObject         *object){
+
+	GtkMenuBar * menubar;
+	GtkMenuBarPrivate * priv;
+LOG_FUNC_NAME;
+	
+	menubar = GTK_MENU_BAR(object);
+	priv = GTK_MENU_BAR_GET_PRIVATE(menubar);
+
+	global_menu_socket_free(priv->socket);
+	G_OBJECT_CLASS(gtk_menu_bar_parent_class)->finalize(object);
+}
+
+static void
+gtk_menu_bar_realize(GtkWidget * widget)
+{
+  GtkMenuBar * menubar = NULL;
+  GtkMenuBarPrivate * priv = NULL;
+  GdkWindowAttr attributes;
+  gint attributes_mask = 0;
+  GlobalMenuNotify notify;
+
+  menubar = GTK_MENU_BAR(widget);
+  priv = GTK_MENU_BAR_GET_PRIVATE(menubar);
+LOG_FUNC_NAME;
+
+  g_return_if_fail (GTK_IS_MENU_SHELL (widget));
+
+//  GTK_WIDGET_SET_FLAGS (widget, GTK_REALIZED); set by parent class realize
+  GTK_WIDGET_CLASS(gtk_menu_bar_parent_class)->realize(widget);
+  //gdk_window_set_user_data (widget->window, widget); I think it is also set
+// parent realize will also create widget->window
+
+
+/*Then we create the float window*/
+  priv->master_window = gdk_window_get_toplevel(gtk_widget_get_parent_window(widget));
+  g_message("Master Window Xid is %p\n", GDK_WINDOW_XWINDOW(priv->master_window));
+
+  attributes.title = "GTK MENUBAR2";
+  attributes.x = widget->allocation.x;
+  attributes.y = widget->allocation.y;
+  attributes.width = widget->requisition.width;
+  attributes.height = widget->requisition.height;
+  attributes.window_type = GDK_WINDOW_TEMP;
+  attributes.wclass = GDK_INPUT_OUTPUT;
+
+  attributes.visual = gtk_widget_get_visual (widget);
+  attributes.colormap = gtk_widget_get_colormap (widget);
+  attributes.event_mask = gtk_widget_get_events (widget);
+  attributes.event_mask |= (GDK_EXPOSURE_MASK |
+			    GDK_BUTTON_PRESS_MASK |
+			    GDK_BUTTON_RELEASE_MASK |
+			    GDK_KEY_PRESS_MASK |
+			    GDK_ENTER_NOTIFY_MASK |
+			    GDK_LEAVE_NOTIFY_MASK);
+
+//  attributes.type_hint = GDK_WINDOW_TYPE_HINT_DOCK;
+
+  attributes_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_COLORMAP | GDK_WA_TITLE;
+  priv->float_window = gdk_window_new (gtk_widget_get_root_window (widget), &attributes, attributes_mask);
+  g_print("Float window created ,XID=%p\n", GDK_WINDOW_XID(priv->float_window));
+  gdk_window_stick(priv->float_window);
+  gdk_window_set_user_data (priv->float_window, widget);
+
+/*********Then the container window *********/
+  attributes.x = 0;
+  attributes.y = 0;
+  attributes.width = widget->allocation.width; /*They are Zeros, potentially will introduce bug*/
+  attributes.height = widget->allocation.height;
+  attributes.window_type = GDK_WINDOW_CHILD;
+  attributes.event_mask = (gtk_widget_get_events (widget) |
+               GDK_EXPOSURE_MASK |
+               GDK_BUTTON1_MOTION_MASK |
+               GDK_POINTER_MOTION_HINT_MASK |
+               GDK_BUTTON_PRESS_MASK |
+                GDK_BUTTON_RELEASE_MASK);
+  attributes_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_COLORMAP;
+  priv->container_window = gdk_window_new (widget->window, &attributes, attributes_mask);
+  gdk_window_set_user_data (priv->container_window, widget);
+/*Then move all the exsited menuitems's gdk parent window to the container */
+  gtk_container_forall(GTK_CONTAINER(widget), 
+			gtk_widget_set_parent_window, (gpointer)(priv->container_window));
+
+/*Set some painting hints*/
+  gtk_style_set_background (widget->style, widget->window, GTK_WIDGET_STATE (menubar));
+  gtk_style_set_background (widget->style, priv->container_window, GTK_WIDGET_STATE (menubar));
+  gtk_style_set_background (widget->style, priv->float_window, GTK_WIDGET_STATE (menubar));
+  gdk_window_set_back_pixmap (widget->window, NULL, TRUE);
+
+
+/*tell the server a new menubar is created*/
+  priv->globalized = global_menu_socket_connect_by_name(priv->socket, MENU_SERVER_NAME);
+
+/*THE MOST IMPORTANT CHANGE WILL BE HERE*/
+/*if we want to disable global menubar, or move them back, change this line to widget->window*/
+  if(priv->globalized){
+	  gdk_window_reparent(priv->container_window, priv->float_window, 0, 0); 
+	  notify.type = GM_NOTIFY_NEW;
+      notify.ClientNew.client_xid = GDK_WINDOW_XWINDOW(priv->socket->window);
+	  notify.ClientNew.float_xid = GDK_WINDOW_XWINDOW(priv->float_window);
+	  notify.ClientNew.master_xid = GDK_WINDOW_XWINDOW(priv->master_window);
+	  global_menu_socket_send(priv->socket, &notify);
+	  widget->style->ythickness = 0;
+  } else {
+	  gdk_window_reparent(priv->container_window, widget->window, 0, 0); 
+  }
+
+}
+
+static void
+gtk_menu_bar_unrealize(GtkWidget * widget)
+{
+  GtkMenuBar * menubar = NULL;
+  GtkMenuBarPrivate * priv = NULL;
+
+LOG_FUNC_NAME;
+
+  menubar = GTK_MENU_BAR(widget);
+  priv = GTK_MENU_BAR_GET_PRIVATE(menubar);
+
+  if(priv->globalized){
+	  GlobalMenuNotify notify;
+	  notify.type = GM_NOTIFY_DESTROY;
+      notify.ClientDestroy.client_xid = GDK_WINDOW_XWINDOW(priv->socket->window);
+	  notify.ClientDestroy.float_xid = GDK_WINDOW_XWINDOW(priv->float_window);
+	  notify.ClientDestroy.master_xid = GDK_WINDOW_XWINDOW(priv->master_window);
+	  global_menu_socket_send(priv->socket, &notify);
+  }
+
+  gdk_window_set_user_data (priv->container_window, NULL);
+  gdk_window_destroy (priv->container_window);
+  priv->container_window = NULL;
+
+  gdk_window_set_user_data (priv->float_window, NULL);
+  gdk_window_destroy (priv->float_window);
+  priv->float_window = NULL;
+  GTK_WIDGET_CLASS(gtk_menu_bar_parent_class)->unrealize(widget); 
+}
+
+static void
+gtk_menu_bar_map_child (GtkWidget *child,
+             gpointer   client_data)
+{
+  if (GTK_WIDGET_VISIBLE (child) &&
+      GTK_WIDGET_CHILD_VISIBLE (child) &&
+      !GTK_WIDGET_MAPPED (child))
+    gtk_widget_map (child);
+}
+
+static void
+gtk_menu_bar_map(GtkWidget * widget){
+  GtkMenuBar * menubar = NULL;
+  GtkMenuBarPrivate * priv = NULL;
+LOG_FUNC_NAME;
+
+  menubar = GTK_MENU_BAR(widget);
+  priv = GTK_MENU_BAR_GET_PRIVATE(menubar);
+
+  GTK_WIDGET_SET_FLAGS (widget, GTK_MAPPED);
+
+  gtk_container_forall (GTK_CONTAINER (widget),
+            gtk_menu_bar_map_child,
+            NULL);
+
+  gdk_window_move_resize(priv->container_window,
+		0, 0, 
+        widget->requisition.width,
+        widget->requisition.height);
+
+  gdk_window_show(priv->container_window);
+  if(priv->globalized){
+	  gdk_window_show(priv->float_window);
+
+  }
+  gdk_window_show(widget->window);
+}
+
+static void
+gtk_menu_bar_unmap(GtkWidget * widget){
+  GtkMenuBar * menubar = NULL;
+  GtkMenuBarPrivate * priv = NULL;
+LOG_FUNC_NAME;
+
+  menubar = GTK_MENU_BAR(widget);
+  priv = GTK_MENU_BAR_GET_PRIVATE(menubar);
+
+  GTK_WIDGET_UNSET_FLAGS (widget, GTK_MAPPED); 
+
+  gdk_window_hide(priv->float_window);
+  gdk_window_hide(widget->window);
+}
+
+/*****************************
+ * overide gtk_menu_shell_insert, because we want to set proper parent gdkwindow
+ * *****************/
+static void
+gtk_menu_bar_real_insert(GtkMenuShell * menu_shell, GtkWidget * child, gint position){
+  GtkMenuBar * menubar = NULL;
+  GtkMenuBarPrivate * priv = NULL;
+LOG_FUNC_NAME;
+
+  menubar = GTK_MENU_BAR(menu_shell);
+  priv = GTK_MENU_BAR_GET_PRIVATE(menubar);
+
+  GTK_MENU_SHELL_CLASS(gtk_menu_bar_parent_class)->insert(menu_shell, child, position);
+  gtk_widget_set_parent_window(child, priv->container_window);
+}
+static void
+gtk_menu_bar_notify_size_allocate_cb(GlobalMenuSocket * socket, 
+		GlobalMenuNotify * notify,
+		GtkMenuBar * menubar){
+	GtkMenuBarPrivate * priv;
+	GtkAllocation allocation;
+	priv = GTK_MENU_BAR_GET_PRIVATE(menubar);
+	g_message("Size Allocate Notify Received");
+	allocation.x = 0;
+	allocation.y = 0;
+	allocation.width = notify->SizeAllocate.width;
+	allocation.height = notify->SizeAllocate.height;
+	gdk_window_resize(priv->float_window, 
+		allocation.width, allocation.height);
+	gdk_window_resize(priv->container_window, 
+		allocation.width, allocation.height);
+	gtk_menu_bar_size_allocate(menubar, &allocation);
+}
 #define __GTK_MENU_BAR_C__
 #include "gtkaliasdef.c"
--- /dev/null	2007-12-30 12:14:21.429092025 -0500
+++ gtk/gtkmenuembed-x11.h	2007-12-30 21:28:11.000000000 -0500
@@ -0,0 +1,239 @@
+typedef enum {
+	GM_NOTIFY_NOT_GM,
+	GM_NOTIFY_MIN,
+	GM_NOTIFY_NEW,
+	GM_NOTIFY_DESTROY,
+	GM_NOTIFY_SERVER_NEW,
+	GM_NOTIFY_SERVER_DESTROY,
+	GM_NOTIFY_SIZE_ALLOCATE,
+	GM_NOTIFY_MAX,
+} GlobalMenuNotifyType;
+#define ATOM_STRING "_GTKMENUBAR_EMBED"
+#define MENU_SERVER_NAME "GTK MENU BAR SERVER"
+#define MENU_CLIENT_NAME "GTK MENU BAR CLIENT"
+
+typedef struct _GlobalMenuNotify {
+	GlobalMenuNotifyType type;
+	union{
+	struct {
+		gulong param1;
+		gulong param2;
+		gulong param3;
+	}; /*general*/
+		struct {
+			Window client_xid;
+			Window float_xid;
+			Window master_xid;
+		} ClientNew;
+		struct {
+			Window client_xid;
+			Window float_xid;
+			Window master_xid;
+		} ClientDestroy;
+		struct {
+			Window server_xid;
+		} ServerNew;
+		struct {
+			Window server_xid;
+		} ServerDestroy;
+		struct {
+			Window server_xid;
+			glong width;
+			glong height;
+		} SizeAllocate;
+	};
+} GlobalMenuNotify;
+
+typedef struct _GlobalMenuSocket GlobalMenuSocket;
+
+typedef void (*GlobalMenuCallback)(GlobalMenuSocket* socket, 
+	GlobalMenuNotify * notify, gpointer data);
+
+struct _GlobalMenuSocket {
+	gchar * name;
+	GdkWindow * window;
+	GdkDisplay * display;
+	GlobalMenuCallback callbacks[GM_NOTIFY_MAX];
+	gpointer userdata;
+	Window dest_xid; // Where to connect to
+};
+
+
+#ifdef INCLUDE_SOURCE
+static const gchar * global_menu_notify_get_name(GlobalMenuNotifyType type){
+#define CASE(x) case x: return # x;
+	switch(type){
+	CASE(GM_NOTIFY_NOT_GM)
+	CASE(GM_NOTIFY_NEW)
+	CASE(GM_NOTIFY_DESTROY)
+	CASE(GM_NOTIFY_SERVER_NEW)
+	CASE(GM_NOTIFY_SERVER_DESTROY)
+	CASE(GM_NOTIFY_SIZE_ALLOCATE)
+	default:
+		return "Unknown notification";
+	}
+#undef CASE
+}
+
+static gboolean global_menu_xevent_to_notify(XEvent * xevent, GlobalMenuNotify * notify){
+	GdkDisplay * display = NULL;
+
+	if(notify == NULL){ 
+		g_warning("notify is NULL\n");
+		return FALSE;
+	}
+
+	notify->type = GM_NOTIFY_NOT_GM;
+	if(xevent->type == ClientMessage){
+		g_message("XClient notify translating");
+
+		display = gdk_x11_lookup_xdisplay(xevent->xclient.display);
+		if(display == NULL){
+			g_warning("Message not from a gdk managed display, ignore it\n");
+			return FALSE;		
+		}
+		if( xevent->xclient.message_type == 
+			gdk_x11_get_xatom_by_name_for_display(display, ATOM_STRING)){
+			notify->type = xevent->xclient.data.l[1];
+			notify->param1 = xevent->xclient.data.l[2];
+			notify->param2 = xevent->xclient.data.l[3];
+			notify->param3 = xevent->xclient.data.l[4];
+			g_message("Global Menu Notification: %s, %ld, %ld, %ld\n",
+				global_menu_notify_get_name(notify->type),
+					notify->param1, notify->param2, notify->param3);
+			return TRUE;
+		}
+	}
+	return FALSE;
+}
+
+static GdkFilterReturn global_menu_socket_dispatcher(XEvent * xevent, GdkEvent * event, GlobalMenuSocket * socket){
+	GlobalMenuNotify notify;
+	GlobalMenuNotifyType type;
+	if(global_menu_xevent_to_notify(xevent, &notify)){
+		g_message("global menu notify received");
+		type = notify.type;
+		if(socket->callbacks[type] ){
+			(*(socket->callbacks[type]))(socket, &notify, socket->userdata);
+		}
+		return GDK_FILTER_REMOVE;
+	}
+	return GDK_FILTER_CONTINUE;
+	
+}
+
+static GlobalMenuSocket * global_menu_socket_new(gchar * name, gpointer userdata){
+	GdkWindowAttr attr;
+	GdkWindowAttributesType mask;
+
+	GlobalMenuSocket * socket = g_new0(GlobalMenuSocket, 1);
+	attr.title = name;
+	attr.wclass = GDK_INPUT_ONLY;
+	attr.window_type = GDK_WINDOW_TOPLEVEL;
+
+	mask = GDK_WA_TITLE;
+	socket->window = gdk_window_new(NULL, &attr, mask);
+	socket->name = g_strdup(name);
+	socket->userdata = userdata,
+	socket->display = gdk_drawable_get_display(socket->window);
+
+	gdk_window_add_filter(socket->window, (GdkFilterFunc)global_menu_socket_dispatcher, socket);
+
+	return socket;
+}
+static void global_menu_socket_free(GlobalMenuSocket * socket){
+	gdk_window_destroy(socket->window);
+	g_free(socket->name);
+	g_free(socket);
+}
+static void global_menu_socket_set_callback(GlobalMenuSocket * socket, 
+		GlobalMenuNotifyType type, GlobalMenuCallback cb){
+	g_return_if_fail( type > GM_NOTIFY_MIN && type < GM_NOTIFY_MAX);
+	g_return_if_fail( socket );
+	g_return_if_fail( cb );
+	
+	socket->callbacks[type] = cb;
+}
+static gboolean global_menu_socket_connect_by_name(GlobalMenuSocket * socket, gchar * dest_name){
+	GdkScreen * screen;
+	GdkWindow * root = NULL;
+	Window root_xid;
+	Window root_return;
+	Window parent_return;
+	Window * children_return;
+	unsigned int nchildren_return;
+	unsigned int i;
+	gboolean connected = FALSE;
+
+	g_return_val_if_fail( socket ,FALSE);
+	g_return_val_if_fail( dest_name ,FALSE);
+	
+	screen = gdk_drawable_get_screen(socket->window);
+	root = gdk_screen_get_root_window(screen);
+	g_return_val_if_fail( screen , FALSE);	
+	g_return_val_if_fail( root , FALSE);	
+
+	gdk_error_trap_push();
+	XQueryTree(GDK_DISPLAY_XDISPLAY(socket->display),
+		GDK_WINDOW_XWINDOW(root),
+		&root_return,
+		&parent_return,
+		&children_return,
+		&nchildren_return);
+	gdk_error_trap_pop();
+
+	g_return_val_if_fail( children_return , FALSE );
+
+	for(i = 0; i < nchildren_return; i++){
+		Atom type_return;
+		Atom type_req = gdk_x11_get_xatom_by_name_for_display (socket->display, "UTF8_STRING");
+		gint format_return;
+		gulong nitems_return;
+		gulong bytes_after_return;
+		gchar * data;
+
+		if(XGetWindowProperty (GDK_DISPLAY_XDISPLAY (socket->display), children_return[i],
+						  gdk_x11_get_xatom_by_name_for_display (socket->display, "_NET_WM_NAME"),
+                          0, G_MAXLONG, False, type_req, &type_return,
+                          &format_return, &nitems_return, &bytes_after_return,
+                          &data) == Success)
+		if(type_return == type_req){
+			if(g_str_equal(dest_name, data)){
+				g_message("Destination found, remember it");
+				socket->dest_xid = children_return[i];
+				connected = TRUE;
+				break;
+			}
+		}
+	}
+	XFree(children_return);
+	return connected;
+}
+
+static Window global_menu_socket_get_xid(GlobalMenuSocket * socket){
+	return GDK_WINDOW_XWINDOW(socket->window);
+}
+static void global_menu_socket_send_to(GlobalMenuSocket * socket, Window xid, GlobalMenuNotify * message){
+	XClientMessageEvent xclient;
+
+	memset (&xclient, 0, sizeof (xclient));
+	xclient.window = xid;
+	xclient.type = ClientMessage;
+	xclient.message_type = gdk_x11_get_xatom_by_name_for_display (socket->display, ATOM_STRING);
+	xclient.format = 32;
+	xclient.data.l[0] = gtk_get_current_event_time();
+	xclient.data.l[1] = message->type;
+	xclient.data.l[2] = message->param1;
+	xclient.data.l[3] = message->param2;
+	xclient.data.l[4] = message->param3;
+	gdk_error_trap_push ();
+	XSendEvent (GDK_DISPLAY_XDISPLAY(socket->display),
+		  xid,
+		  False, NoEventMask, (XEvent *)&xclient);
+	gdk_display_sync (socket->display);
+	gdk_error_trap_pop ();
+}
+static void global_menu_socket_send(GlobalMenuSocket * socket, GlobalMenuNotify * message){
+	global_menu_socket_send_to(socket, socket->dest_xid, message);
+}
+#endif
