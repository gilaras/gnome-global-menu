--- gtk/gtkmenubar.orig	2007-12-28 15:31:03.000000000 -0500
+++ gtk/gtkmenubar.c	2007-12-28 15:31:50.000000000 -0500
@@ -25,7 +25,7 @@
  */
 
 #define GTK_MENU_INTERNALS
-
+#define LOG_FUNC_NAME g_print("%s Invoked\n", __func__);
 #include <config.h>
 #include "gdk/gdkkeysyms.h"
 #include "gtkbindings.h"
@@ -39,6 +39,7 @@
 #include "gtkprivate.h"
 #include "gtkalias.h"
 
+#include "x11/gdkx.h" /*remove it in the future!*/
 
 #define BORDER_SPACING  0
 #define DEFAULT_IPADDING 1
@@ -55,6 +56,10 @@
 {
   GtkPackDirection pack_direction;
   GtkPackDirection child_pack_direction;
+  GdkWindow * container_window;
+  GdkWindow * float_window;
+  gboolean * globalized; 
+  GtkRequisition children_requisition;
 };
 
 #define GTK_MENU_BAR_GET_PRIVATE(o)  \
@@ -82,8 +87,15 @@
 static gint gtk_menu_bar_get_popup_delay   (GtkMenuShell    *menu_shell);
 static void gtk_menu_bar_move_current      (GtkMenuShell     *menu_shell,
                                             GtkMenuDirectionType direction);
+static void gtk_menu_bar_realize            (GtkWidget         *widget);
+static void gtk_menu_bar_unrealize            (GtkWidget         *widget);
+static void gtk_menu_bar_map				(GtkWidget * widget);
+static void gtk_menu_bar_unmap				(GtkWidget * widget);
+
+static void gtk_menu_bar_real_insert (GtkMenuShell * menu_shell, GtkWidget * child, gint position);
 
 static GtkShadowType get_shadow_type   (GtkMenuBar      *menubar);
+static void allocate_size (GtkWidget     *widget, GtkAllocation *allocation);
 
 G_DEFINE_TYPE (GtkMenuBar, gtk_menu_bar, GTK_TYPE_MENU_SHELL)
 
@@ -107,10 +119,15 @@
   widget_class->size_allocate = gtk_menu_bar_size_allocate;
   widget_class->expose_event = gtk_menu_bar_expose;
   widget_class->hierarchy_changed = gtk_menu_bar_hierarchy_changed;
-  
+  widget_class->realize = gtk_menu_bar_realize;  
+  widget_class->unrealize = gtk_menu_bar_unrealize;  
+  widget_class->map = gtk_menu_bar_map;
+  widget_class->unmap = gtk_menu_bar_unmap;
+
   menu_shell_class->submenu_placement = GTK_TOP_BOTTOM;
   menu_shell_class->get_popup_delay = gtk_menu_bar_get_popup_delay;
   menu_shell_class->move_current = gtk_menu_bar_move_current;
+  menu_shell_class->insert = gtk_menu_bar_real_insert;
 
   binding_set = gtk_binding_set_by_class (class);
   gtk_binding_entry_add_signal (binding_set,
@@ -220,11 +237,19 @@
 static void
 gtk_menu_bar_init (GtkMenuBar *object)
 {
+  GtkMenuBarPrivate * priv = GTK_MENU_BAR_GET_PRIVATE(object);
+
+LOG_FUNC_NAME;
+
+  priv->globalized = TRUE;
+  priv->container_window = NULL;
+  priv->float_window = NULL;
 }
 
 GtkWidget*
 gtk_menu_bar_new (void)
 {
+LOG_FUNC_NAME;
   return g_object_new (GTK_TYPE_MENU_BAR, NULL);
 }
 
@@ -273,7 +298,7 @@
 }
 
 static void
-gtk_menu_bar_size_request (GtkWidget      *widget,
+calculate_size_request (GtkWidget      *widget,
 			   GtkRequisition *requisition)
 {
   GtkMenuBar *menu_bar;
@@ -285,6 +310,7 @@
   GtkRequisition child_requisition;
   gint ipadding;
 
+LOG_FUNC_NAME;
   g_return_if_fail (GTK_IS_MENU_BAR (widget));
   g_return_if_fail (requisition != NULL);
 
@@ -353,7 +379,69 @@
 }
 
 static void
-gtk_menu_bar_size_allocate (GtkWidget     *widget,
+gtk_menu_bar_size_request (GtkWidget *widget,
+			   GtkRequisition * requisition){
+  GtkMenuBar *menu_bar;
+  GtkMenuBarPrivate *priv;
+LOG_FUNC_NAME;
+
+  g_return_if_fail (GTK_IS_MENU_BAR (widget));
+  g_return_if_fail (requisition != NULL);
+
+  menu_bar = GTK_MENU_BAR (widget);
+  priv = GTK_MENU_BAR_GET_PRIVATE (menu_bar);
+
+  if(priv->globalized){
+	requisition->width = 0;
+    requisition->height = 0;
+  } else
+    calculate_size_request(widget, requisition);
+}
+static void
+gtk_menu_bar_size_allocate(GtkWidget * widget,
+				GtkAllocation * allocation)
+{
+  GtkMenuBar *menu_bar;
+  GtkMenuShell *menu_shell;
+  GtkMenuBarPrivate *priv;
+  GtkWidget *child;
+  GList *children;
+  GtkAllocation child_allocation;
+  GtkRequisition child_requisition;
+  guint offset;
+  GtkTextDirection direction;
+  gint ltr_x, ltr_y;
+  gint ipadding;
+
+LOG_FUNC_NAME;
+  g_return_if_fail (GTK_IS_MENU_BAR (widget));
+  g_return_if_fail (allocation != NULL);
+
+  menu_bar = GTK_MENU_BAR (widget);
+  menu_shell = GTK_MENU_SHELL (widget);
+  priv = GTK_MENU_BAR_GET_PRIVATE (menu_bar);
+
+  widget->allocation = *allocation;
+  g_print("Allocation for widget is w=%d, h=%d\n", allocation->width, allocation->height);
+
+  if(priv->globalized){ /*Ah, greedy!*/
+    /*What I realy need if not limited by allocation?*/
+    calculate_size_request(widget, &priv->children_requisition);
+
+    allocation->width = priv->children_requisition.width;
+    allocation->height = priv->children_requisition.height;
+  }
+
+  if (GTK_WIDGET_REALIZED (widget)) 
+    {
+		gdk_window_move_resize (widget->window,
+					allocation->x, allocation->y,
+					allocation->width, allocation->height);
+    }
+	allocate_size(widget, allocation);
+}
+static void
+allocate_size (GtkWidget     *widget,
 			    GtkAllocation *allocation)
 {
   GtkMenuBar *menu_bar;
@@ -368,6 +456,7 @@
   gint ltr_x, ltr_y;
   gint ipadding;
 
+LOG_FUNC_NAME;
   g_return_if_fail (GTK_IS_MENU_BAR (widget));
   g_return_if_fail (allocation != NULL);
 
@@ -375,13 +464,21 @@
   menu_shell = GTK_MENU_SHELL (widget);
   priv = GTK_MENU_BAR_GET_PRIVATE (menu_bar);
 
-  direction = gtk_widget_get_direction (widget);
+  g_print("Allocation is w=%d, h=%d\n", allocation->width, allocation->height);
 
-  widget->allocation = *allocation;
-  if (GTK_WIDGET_REALIZED (widget))
-    gdk_window_move_resize (widget->window,
-			    allocation->x, allocation->y,
-			    allocation->width, allocation->height);
+  if (GTK_WIDGET_REALIZED (widget)) 
+    {
+		if(priv->globalized){
+			gdk_window_move_resize (priv->float_window,
+						0, 0,
+						allocation->width, allocation->height);
+		}
+		gdk_window_move_resize (priv->container_window,
+					0, 0,
+					allocation->width, allocation->height);
+    }
+
+  direction = gtk_widget_get_direction (widget);
 
   gtk_widget_style_get (widget, "internal-padding", &ipadding, NULL);
   
@@ -532,6 +629,7 @@
 {
   g_return_val_if_fail (GTK_IS_MENU_BAR (widget), FALSE);
   g_return_val_if_fail (event != NULL, FALSE);
+LOG_FUNC_NAME;
 
   if (GTK_WIDGET_DRAWABLE (widget))
     {
@@ -581,6 +679,7 @@
 set_menu_bars (GtkWindow *window,
 	       GList     *menubars)
 {
+LOG_FUNC_NAME;
   g_object_set_data (G_OBJECT (window), I_("gtk-menu-bar-list"), menubars);
 }
 
@@ -591,6 +690,7 @@
 {
   gchar *accel = NULL;
   gboolean retval = FALSE;
+LOG_FUNC_NAME;
   
   g_object_get (gtk_widget_get_settings (widget),
                 "gtk-menu-bar-accel", &accel,
@@ -645,6 +745,7 @@
                GtkMenuBar *menubar)
 {
   GList *menubars = get_menu_bars (window);
+LOG_FUNC_NAME;
 
   if (!menubars)
     {
@@ -662,6 +763,7 @@
                     GtkMenuBar *menubar)
 {
   GList *menubars = get_menu_bars (window);
+LOG_FUNC_NAME;
 
   menubars = g_list_remove (menubars, menubar);
 
@@ -681,6 +783,7 @@
 {
   GtkWidget *toplevel;  
   GtkMenuBar *menubar;
+LOG_FUNC_NAME;
 
   menubar = GTK_MENU_BAR (widget);
 
@@ -693,6 +796,223 @@
     add_to_window (GTK_WINDOW (toplevel), menubar);
 }
 
+static void
+gtk_menu_bar_map_child (GtkWidget *child,
+             gpointer   client_data)
+{
+  if (GTK_WIDGET_VISIBLE (child) &&
+      GTK_WIDGET_CHILD_VISIBLE (child) &&
+      !GTK_WIDGET_MAPPED (child))
+    gtk_widget_map (child);
+}
+
+static void
+gtk_menu_bar_map(GtkWidget * widget){
+  GtkMenuBar * menubar = NULL;
+  GtkMenuBarPrivate * priv = NULL;
+LOG_FUNC_NAME;
+
+  menubar = GTK_MENU_BAR(widget);
+  priv = GTK_MENU_BAR_GET_PRIVATE(menubar);
+
+  GTK_WIDGET_SET_FLAGS (widget, GTK_MAPPED);
+
+  gtk_container_forall (GTK_CONTAINER (widget),
+            gtk_menu_bar_map_child,
+            NULL);
+
+  gdk_window_move_resize(priv->container_window,
+		0, 0, 
+        priv->children_requisition.width,
+        priv->children_requisition.height);
+
+  gdk_window_show(priv->container_window);
+  if(priv->globalized){
+	  gdk_window_show(priv->float_window);
+
+  }
+  gdk_window_show(widget->window);
+}
+
+static void
+gtk_menu_bar_unmap(GtkWidget * widget){
+  GtkMenuBar * menubar = NULL;
+  GtkMenuBarPrivate * priv = NULL;
+LOG_FUNC_NAME;
+
+  menubar = GTK_MENU_BAR(widget);
+  priv = GTK_MENU_BAR_GET_PRIVATE(menubar);
+
+  GTK_WIDGET_UNSET_FLAGS (widget, GTK_MAPPED); 
+
+  gdk_window_hide(priv->float_window);
+  gdk_window_hide(widget->window);
+}
+
+/*****************************
+ * overide gtk_menu_shell_insert, because we want to set proper parent gdkwindow
+ * *****************/
+static void
+gtk_menu_bar_real_insert(GtkMenuShell * menu_shell, GtkWidget * child, gint position){
+  GtkMenuBar * menubar = NULL;
+  GtkMenuBarPrivate * priv = NULL;
+LOG_FUNC_NAME;
+
+  menubar = GTK_MENU_BAR(menu_shell);
+  priv = GTK_MENU_BAR_GET_PRIVATE(menubar);
+
+  GTK_MENU_SHELL_CLASS(gtk_menu_bar_parent_class)->insert(menu_shell, child, position);
+  gtk_widget_set_parent_window(child, priv->container_window);
+}
+
+static GdkFilterReturn 
+gtk_menu_bar_float_window_filter_cb(XEvent * xevent, 
+			GdkEvent * event, GtkMenuBar * menubar){
+  GdkFilterReturn rt = GDK_FILTER_CONTINUE;
+  GdkDisplay * display;
+
+  display = gdk_drawable_get_display(event->any.window);
+  switch(xevent->type){
+    case ClientMessage:
+      if(xevent->xclient.message_type == gdk_x11_get_xatom_by_name_for_display (display, "_GTKMENUBAR_EMBED")){
+			g_print("Menu bar Embedding message received!\n");
+			rt = GDK_FILTER_REMOVE;
+			if(xevent->xclient.data.l[1] == 0)//magic number, for resize
+			{
+			   GtkAllocation allocation;
+			   allocation.x = 0;
+               allocation.y = 0;
+               allocation.width = xevent->xclient.data.l[2];
+               allocation.height = xevent->xclient.data.l[3];
+  g_print("Allocation from menu server is w=%d, h=%d\n", allocation.width, allocation.height);
+			   allocate_size(menubar, &allocation);	
+			}
+      }
+      if(xevent->xclient.message_type == gdk_x11_get_xatom_by_name_for_display (display, "WM_DELETE_WINDOW")){
+			g_print("Delete Xevent received, ignore it");
+			rt = GDK_FILTER_REMOVE;
+      }
+	  break;
+    case ReparentNotify:
+      g_print("Reparent Notify received\n");
+      rt = GDK_FILTER_REMOVE;
+      break;
+  }
+  return rt;
+}
+
+static void
+gtk_menu_bar_realize(GtkWidget * widget)
+{
+  GtkMenuBar * menubar = NULL;
+  GtkMenuBarPrivate * priv = NULL;
+  GdkWindowAttr attributes;
+  GdkWindow * master_window = NULL;
+  gint attributes_mask = 0;
+
+  menubar = GTK_MENU_BAR(widget);
+  priv = GTK_MENU_BAR_GET_PRIVATE(menubar);
+LOG_FUNC_NAME;
+
+  g_return_if_fail (GTK_IS_MENU_SHELL (widget));
+
+//  GTK_WIDGET_SET_FLAGS (widget, GTK_REALIZED); set by parent class realize
+  GTK_WIDGET_CLASS(gtk_menu_bar_parent_class)->realize(widget);
+  //gdk_window_set_user_data (widget->window, widget); I think it is also set
+// parent realize will also create widget->window
+
+
+/*Then we create the float window*/
+  master_window = gdk_window_get_toplevel(gtk_widget_get_parent_window(widget));
+  g_print("Master Window Xid is %p\n", GDK_WINDOW_XID(master_window));
+  attributes.title = "GTK MENUBAR2";
+  attributes.x = widget->allocation.x;
+  attributes.y = widget->allocation.y;
+  attributes.width = priv->children_requisition.width;
+  attributes.height = priv->children_requisition.height;
+  attributes.window_type = GDK_WINDOW_TOPLEVEL;
+  attributes.wclass = GDK_INPUT_OUTPUT;
+/*
+  attributes.wmclass_name = g_strdup(g_get_prgname());
+  attributes.wmclass_class = g_strdup(gdk_get_program_class());
+  This doesn't help solving the icon problem. So disable them. 
+*/
+  attributes.visual = gtk_widget_get_visual (widget);
+  attributes.colormap = gtk_widget_get_colormap (widget);
+  attributes.event_mask = gtk_widget_get_events (widget);
+  attributes.event_mask |= (GDK_EXPOSURE_MASK |
+			    GDK_BUTTON_PRESS_MASK |
+			    GDK_BUTTON_RELEASE_MASK |
+			    GDK_KEY_PRESS_MASK |
+			    GDK_ENTER_NOTIFY_MASK |
+			    GDK_LEAVE_NOTIFY_MASK);
+
+  attributes.type_hint = GDK_WINDOW_TYPE_HINT_DOCK;
+
+  attributes_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_COLORMAP | GDK_WA_TYPE_HINT | GDK_WA_TITLE | GDK_WA_WMCLASS;
+  priv->float_window = gdk_window_new (gtk_widget_get_root_window (widget), &attributes, attributes_mask);
+  g_print("Float window created ,XID=%p\n", GDK_WINDOW_XID(priv->float_window));
+  gdk_window_set_transient_for (priv->float_window, master_window);
+  gdk_window_stick(priv->float_window);
+  gdk_window_set_user_data (priv->float_window, widget);
+  gdk_window_add_filter(priv->float_window, gtk_menu_bar_float_window_filter_cb, widget);
+
+/*********Then the container window *********/
+  attributes.x = 0;
+  attributes.y = 0;
+  attributes.width = widget->allocation.width; /*They are Zeros, potentially will introduce bug*/
+  attributes.height = widget->allocation.height;
+  attributes.window_type = GDK_WINDOW_CHILD;
+  attributes.event_mask = (gtk_widget_get_events (widget) |
+               GDK_EXPOSURE_MASK |
+               GDK_BUTTON1_MOTION_MASK |
+               GDK_POINTER_MOTION_HINT_MASK |
+               GDK_BUTTON_PRESS_MASK |
+                GDK_BUTTON_RELEASE_MASK);
+  attributes_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_COLORMAP;
+  priv->container_window = gdk_window_new (widget->window, &attributes, attributes_mask);
+  gdk_window_set_user_data (priv->container_window, widget);
+
+/*THE MOST IMPORTANT CHANGE WILL BE HERE*/
+/*if we want to disable global menubar, or move them back, change this line to widget->window*/
+  if(priv->globalized){
+	  gdk_window_reparent(priv->container_window, priv->float_window, 0, 0); 
+  } else {
+	  gdk_window_reparent(priv->container_window, widget->window, 0, 0); 
+  }
+/*Set some painting hints*/
+  gtk_style_set_background (widget->style, widget->window, GTK_WIDGET_STATE (menubar));
+  gtk_style_set_background (widget->style, priv->container_window, GTK_WIDGET_STATE (menubar));
+  gtk_style_set_background (widget->style, priv->float_window, GTK_WIDGET_STATE (menubar));
+  gdk_window_set_back_pixmap (widget->window, NULL, TRUE);
+
+/*Then move all the exsited menuitems's gdk parent window to the container */
+  gtk_container_forall(GTK_CONTAINER(widget), 
+			gtk_widget_set_parent_window, (gpointer)(priv->container_window));
+
+}
+static void
+gtk_menu_bar_unrealize(GtkWidget * widget)
+{
+  GtkMenuBar * menubar = NULL;
+  GtkMenuBarPrivate * priv = NULL;
+
+LOG_FUNC_NAME;
+
+  menubar = GTK_MENU_BAR(widget);
+  priv = GTK_MENU_BAR_GET_PRIVATE(menubar);
+
+  gdk_window_set_user_data (priv->container_window, NULL);
+  gdk_window_destroy (priv->container_window);
+  priv->container_window = NULL;
+
+  gdk_window_set_user_data (priv->float_window, NULL);
+  gdk_window_destroy (priv->float_window);
+  priv->float_window = NULL;
+
+  GTK_WIDGET_CLASS(gtk_menu_bar_parent_class)->unrealize(widget); 
+
+}
 /**
  * _gtk_menu_bar_cycle_focus:
  * @menubar: a #GtkMenuBar
@@ -706,6 +1026,7 @@
 {
   GtkWidget *toplevel = gtk_widget_get_toplevel (GTK_WIDGET (menubar));
   GtkMenuItem *to_activate = NULL;
+LOG_FUNC_NAME;
 
   if (GTK_WIDGET_TOPLEVEL (toplevel))
     {
@@ -742,6 +1063,7 @@
 get_shadow_type (GtkMenuBar *menubar)
 {
   GtkShadowType shadow_type = GTK_SHADOW_OUT;
+LOG_FUNC_NAME;
   
   gtk_widget_style_get (GTK_WIDGET (menubar),
 			"shadow-type", &shadow_type,
@@ -769,6 +1091,7 @@
   GtkMenuBar *menubar = GTK_MENU_BAR (menu_shell);
   GtkTextDirection text_dir;
   GtkPackDirection pack_dir;
+LOG_FUNC_NAME;
 
   text_dir = gtk_widget_get_direction (GTK_WIDGET (menubar));
   pack_dir = gtk_menu_bar_get_pack_direction (menubar);
