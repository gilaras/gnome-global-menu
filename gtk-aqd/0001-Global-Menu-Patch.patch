diff --git a/gtk/gtkmenubar.c b/gtk/gtkmenubar.c
index 8be9682..1cb979d 100644
--- a/gtk/gtkmenubar.c
+++ b/gtk/gtkmenubar.c
@@ -39,7 +39,6 @@
 #include "gtkprivate.h"
 #include "gtkalias.h"
 
-
 #define BORDER_SPACING  0
 #define DEFAULT_IPADDING 1
 
@@ -47,7 +46,8 @@
 enum {
   PROP_0,
   PROP_PACK_DIRECTION,
-  PROP_CHILD_PACK_DIRECTION
+  PROP_CHILD_PACK_DIRECTION,
+  PROP_LOCAL
 };
 
 typedef struct _GtkMenuBarPrivate GtkMenuBarPrivate;
@@ -55,6 +55,7 @@ struct _GtkMenuBarPrivate
 {
   GtkPackDirection pack_direction;
   GtkPackDirection child_pack_direction;
+  gboolean islocal;
 };
 
 #define GTK_MENU_BAR_GET_PRIVATE(o)  \
@@ -73,6 +74,7 @@ static void gtk_menu_bar_size_request      (GtkWidget       *widget,
 					    GtkRequisition  *requisition);
 static void gtk_menu_bar_size_allocate     (GtkWidget       *widget,
 					    GtkAllocation   *allocation);
+static void gtk_menu_bar_map			   (GtkWidget	    *widget);
 static void gtk_menu_bar_paint             (GtkWidget       *widget,
 					    GdkRectangle    *area);
 static gint gtk_menu_bar_expose            (GtkWidget       *widget,
@@ -107,6 +109,7 @@ gtk_menu_bar_class_init (GtkMenuBarClass *class)
   widget_class->size_allocate = gtk_menu_bar_size_allocate;
   widget_class->expose_event = gtk_menu_bar_expose;
   widget_class->hierarchy_changed = gtk_menu_bar_hierarchy_changed;
+  widget_class->map = gtk_menu_bar_map;
   
   menu_shell_class->submenu_placement = GTK_TOP_BOTTOM;
   menu_shell_class->get_popup_delay = gtk_menu_bar_get_popup_delay;
@@ -153,6 +156,22 @@ gtk_menu_bar_class_init (GtkMenuBarClass *class)
 				"move_current", 1,
 				GTK_TYPE_MENU_DIRECTION_TYPE,
 				GTK_MENU_DIR_CHILD);
+  /**
+   * GtkMenuBar:local:
+   *
+   * Control whether the menu is a global menu or a local menu.
+   * A global menu is invisible in the local window. Once attached
+   * with libgnomenu, the menu will be accessible via DBus.
+   *
+   * Since: 2.14
+   */
+  g_object_class_install_property (gobject_class,
+				   PROP_LOCAL,
+				   g_param_spec_boolean ("local",
+ 						      P_("Local Menu or Global Menu"),
+ 						      P_("Whether the menu is a local one"),
+ 						      FALSE,
+ 						      GTK_PARAM_READWRITE));
 
   /**
    * GtkMenuBar:pack-direction:
@@ -235,7 +254,7 @@ gtk_menu_bar_set_property (GObject      *object,
 			   GParamSpec   *pspec)
 {
   GtkMenuBar *menubar = GTK_MENU_BAR (object);
-  
+  GtkMenuBarPrivate *priv = GTK_MENU_BAR_GET_PRIVATE(menubar); 
   switch (prop_id)
     {
     case PROP_PACK_DIRECTION:
@@ -244,6 +263,12 @@ gtk_menu_bar_set_property (GObject      *object,
     case PROP_CHILD_PACK_DIRECTION:
       gtk_menu_bar_set_child_pack_direction (menubar, g_value_get_enum (value));
       break;
+	case PROP_LOCAL:
+	  priv->islocal = g_value_get_boolean (value);
+	  if(GTK_WIDGET_MAPPED (menubar))
+		  gtk_menu_bar_map (menubar);
+	  gtk_widget_queue_resize(menubar);
+	  break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -257,6 +282,7 @@ gtk_menu_bar_get_property (GObject    *object,
 			   GParamSpec *pspec)
 {
   GtkMenuBar *menubar = GTK_MENU_BAR (object);
+  GtkMenuBarPrivate *priv = GTK_MENU_BAR_GET_PRIVATE(menubar); 
   
   switch (prop_id)
     {
@@ -266,6 +292,9 @@ gtk_menu_bar_get_property (GObject    *object,
     case PROP_CHILD_PACK_DIRECTION:
       g_value_set_enum (value, gtk_menu_bar_get_child_pack_direction (menubar));
       break;
+	case PROP_LOCAL:
+	  g_value_set_boolean (value, priv->islocal);
+	  break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -296,6 +325,8 @@ gtk_menu_bar_size_request (GtkWidget      *widget,
       menu_bar = GTK_MENU_BAR (widget);
       menu_shell = GTK_MENU_SHELL (widget);
       priv = GTK_MENU_BAR_GET_PRIVATE (menu_bar);
+      
+	  if(priv->islocal == FALSE) return; /* require no size if non-local*/
 
       nchildren = 0;
       children = menu_shell->children;
@@ -504,6 +535,21 @@ gtk_menu_bar_size_allocate (GtkWidget     *widget,
 }
 
 static void
+gtk_menu_bar_map (GtkWidget    *widget) {
+  GtkMenuBarPrivate *priv;
+  
+  priv = GTK_MENU_BAR_GET_PRIVATE (widget);
+  
+  if(priv->islocal == FALSE) {
+	  GTK_WIDGET_SET_FLAGS (widget, GTK_MAPPED);
+	  if (!GTK_WIDGET_NO_WINDOW (widget))
+		gdk_window_hide (widget->window);
+	  return;
+  }
+  (* GTK_WIDGET_CLASS (gtk_menu_bar_parent_class)->map) (widget);
+}
+
+static void
 gtk_menu_bar_paint (GtkWidget    *widget,
                     GdkRectangle *area)
 {
diff --git a/gtk/gtkmenushell.c b/gtk/gtkmenushell.c
index 63e81b3..f533139 100644
--- a/gtk/gtkmenushell.c
+++ b/gtk/gtkmenushell.c
@@ -58,6 +58,7 @@ enum {
   CANCEL,
   CYCLE_FOCUS,
   MOVE_SELECTED,
+  INSERT,
   LAST_SIGNAL
 };
 
@@ -242,6 +243,14 @@ gtk_menu_shell_class_init (GtkMenuShellClass *klass)
   klass->insert = gtk_menu_shell_real_insert;
   klass->move_selected = gtk_menu_shell_real_move_selected;
 
+  menu_shell_signals[INSERT] =
+    g_signal_new (I_("insert"),
+		  G_OBJECT_CLASS_TYPE (object_class),
+		  G_SIGNAL_RUN_FIRST,
+		  G_STRUCT_OFFSET (GtkMenuShellClass, insert),
+		  NULL, NULL,
+		  _gtk_marshal_VOID__POINTER_INT,
+		  G_TYPE_NONE, 2, GTK_TYPE_WIDGET, G_TYPE_INT);
   menu_shell_signals[DEACTIVATE] =
     g_signal_new (I_("deactivate"),
 		  G_OBJECT_CLASS_TYPE (object_class),
@@ -478,8 +487,7 @@ gtk_menu_shell_insert (GtkMenuShell *menu_shell,
 
   class = GTK_MENU_SHELL_GET_CLASS (menu_shell);
 
-  if (class->insert)
-    class->insert (menu_shell, child, position);
+  g_signal_emit(menu_shell, menu_shell_signals[INSERT], 0, child, position);
 }
 
 static void
